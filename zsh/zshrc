###
# Set shell options
##
setopt auto_menu auto_cd auto_pushd correct auto_name_dirs auto_remove_slash
setopt pushd_ignore_dups rm_star_silent sun_keyboard_hack
setopt extended_glob list_types no_beep always_last_prompt
setopt cdable_vars sh_word_split auto_param_keys
# 補完リストその他でもASCII(7ビット)以上の文字(8ビット)文字を表示 
# # (マルチバイト文字補完)
setopt PRINT_EIGHT_BIT

autoload -Uz is-at-least

###
# Check Command
###
can ()           { where "$1" >/dev/null 2>&1              }
is_linux ()      { [ `uname` = "Linux" ]                   }
is_mac ()        { [ `uname` = "Darwin" ]                  }
is_debian ()     { [ -e '/etc/debian-release' ]            }
is_redhat ()     { [ -e '/etc/redhat-release' ]            }
is_cygwin ()     { [ "$CYGWIN" ]                           }
is_screen ()     { [ "$TERM" = "screen" ] && ! is_tmux     }
is_tmux ()       { [ "$TMUX" != "" ]                       }
is_host ()       { [ ${${(A)${(s:.:)HOST}}[(w)1]} = "$1" ] }
is_ssh_client () { ! [ "$SSH_TTY" ]                        }
#is_ssh_client () { is_cygwin || is_host "pc-igademo" || is_host "mutter" || is_host "vostro200" }

###
# enable auto complete 
###
fpath=($HOME/.zsh/functions(N-/) $fpath)
typeset -U fpath
typeset -U path
autoload -U compinit
if is_cygwin ; then
  compinit -u
else
  compinit
fi

###
# Alias
###
alias l=ls
if is_mac ; then
  if [ which gls >/dev/null 2>&1 ] ; then
    alias ls="ls -G"
  else
    alias ls="gls --color=auto --show-control-chars"
  fi
  alias netstat_osx='lsof -i -P'
  alias dot_files_visible="defaults write com.apple.finder AppleShowAllFiles -bool YES;killall Finder"
  alias dot_files_invisible="defaults write com.apple.finder AppleShowAllFiles -bool NO;killall Finder"
else
  alias ls="ls --color=auto --show-control-chars"
fi
alias la="ls -aF"
alias ll="ls -l"
alias rdesk="rdesktop -r clipboard -zP -ken-us"
alias rdesk_full="rdesk -f"
alias git-submodule-pull="git submodule foreach 'git checkout master; git pull'"
alias git-submodule-fetch="git submodule foreach 'git checkout master; git fetch'"
alias get_viplugin="lftp -u viplugin,667well www.satokar.com"
alias start_selenium_server='java -jar /home/watase/selenium-server/selenium-server.jar'
alias make_patch='diff -u --strip-trailing-cr -B -w'
alias get_myip='curl ifconfig.me'
oppai () {
  perl -le 'use Acme::Oppai;eval q{print "Acme::Oppai"}."->oppai"x(shift||4);' $1
}

alias -g V='| vim -'
alias -g G='| grep '
alias -g L='| less'
alias -g T='| tail -f'
alias -g SPLIT="| perl -le 'map{chomp;print+join\"\\n\",split/\$ARGV[0]/}<STDIN>'"
alias -g JOIN="| perl -le 'print+join\"\$ARGV[0]\",(map{chomp;\$_}<STDIN>)'"
alias -g C='| colorize-http-status.sed'

alias dstat-full='dstat -Tclmdrn'
alias dstat-mem='dstat -Tclm'
alias dstat-cpu='dstat -Tclr'
alias dstat-net='dstat -Tclnd'
alias dstat-disk='dstat -Tcldr'

_SUDO=sudo
# for windows
if is_cygwin ; then
  _SUDO=''
  alias vi=vim
  alias gvim=/usr/local/vim/gvim
  alias traceroute="tracert"
  alias svn="LANG=C LC_ALL=C svn"
fi

if is_host "pc-igademo" ; then
#  export LANG=C
  export GIT_PROXY_COMMAND=$HOME/bin/git-proxy
  alias svn="LANG=ja_JP.UTF-8 LC_ALL=ja_JP.UTF-8 svn"
fi

# gist
# gem install gisty
# git config --global github.user your_id
# git config --global github.token your_token
#
export GISTY_DIR="$HOME/dev/gists"
export GISTY_ACCESS_TOKEN=2f59072d3a498ecc8799176ee657fd2805acc6e9


# ssh agent
if is_ssh_client && ! is_screen && ! is_tmux ; then
  keychain ~/.ssh/id_dsa
  source ~/.keychain/$HOST-sh
fi
agent="$HOME/tmp/ssh-agent-$USER"
if [ -S "$SSH_AUTH_SOCK" ] ; then
  case $SSH_AUTH_SOCK in
    /tmp/*/agent.[0-9]*)
      if ! [ -e "$HOME/tmp" ] ; then
        mkdir "$HOME/tmp"
      fi
      ln -snf "$SSH_AUTH_SOCK" $agent && export SSH_AUTH_SOCK=$agent
  esac
elif [ -S $agent ]; then
  export SSH_AUTH_SOCK=$agent
else
  echo "no ssh-agent"
fi

recovery_ssh_auth_sock_if_lost_sock () {
  if [ -S $SSH_AUTH_SOCK ] ; then
    return
  fi
  netstat -lnx | perl -ne 'print "$1\n" if m|(/tmp/ssh-.+/agent.+)|' | while read agent
  do
    if [ -r $agent ] ; then
      echo "link: '$agent' to '$SSH_AUTH_SOCK'"
      ln -fs $agent $SSH_AUTH_SOCK
      export SSH_AUTH_SOCK
      break
    fi
  done
  echo "Error: agent socket is not found."
}

###
# Perl
###
alias perlsource="PAGER=vim perldoc -m "

develcover () {
  cover -delete
  HARNESS_PERL_SWITCHES=-MDevel::Cover make test
  cover
}

perlpath () {
  local MODULE
  for MODULE in $@
  do
    perl -MClass::Inspector -le "print Class::Inspector->resolved_filename(qq{$MODULE})"
  done
}
perlversion () {
  local MODULE
  for MODULE in $@
  do
    perl -le "eval { require $MODULE}; print qq{${MODULE}: \$${MODULE}::VERSION}"
  done
}
perlsourcew () {
  ${_SUDO} vim $(perlpath $1)
}
perlmodulelist () {
  local modulelist 
  modulelist=(`find $(perl -e 'print join qq{\n}, @INC') -name .packlist | perl -lpe 'm{/auto/(.*)/.packlist}; (my $m = $1) =~ s{/}{::}g; $_ = $m;' | sort | uniq`)
  perlversion $modulelist
}
perlmethod () {
  PERLMETHOD_ALL=; PERLMETHOD_USAGE=
  while getopts a PERLMETHOD_OPT
  do
    case $PERLMETHOD_OPT in
      a) PERLMETHOD_ALL=1;;
      *) PERLMETHOD_USAGE=1;;
    esac
  done
  shift `expr $OPTIND - 1`
  if [ "$PERLMETHOD_USAGE" ] || ! [ "$1" ] ||  [ "$2" ] ; then
    echo -e "perlmethod [-a] Some::Perl::Module -- show methods of Perl Module\n\ta:\tshow private method"
  elif [ "$PERLMETHOD_ALL" ] ; then
    perl -M$1 -le"map{print}sort+grep{defined&{\"$1::\$_\"}}keys%{$1::}"
  else
    perl -M$1 -le"map{print}sort+grep{defined&{\"$1::\$_\"}&&m{^[^_]}}keys%{$1::}"
  fi
  PERLMETHOD_ALL=; PERLMETHOD_USAGE=
}

install-perlbrew () {
  curl -kL http://xrl.us/perlbrewinstall | bash
}

install-cpanm () {
  curl -kL http://cpanmin.us | perl - --self-upgrade $@
}

install-module-install () {
  cpanm Module::Setup \
    Module::Install \
    Module::Install::TestTarget \
    Module::Install::GithubMeta \
    Module::Install::ReadmePodFromPod \
    Module::Install::ReadmeFromPod \
    Module::Install::ReadmeMarkdownFromPod \
    Module::Install::TestBase \
    Test::Requires
}

install-amon2flavor () {
  local path_rcfile
  local cwd
  cwd=`pwd`
  path_rcfile=$(dirname  $(perl -le 'use Cwd; print Cwd::abs_path($ARGV[0])' ~/.vim))
  cd $path_rcfile/perl
  tar czf Amon2-Setup-Flavor-Teng.tar.gz Amon2-Setup-Flavor-Teng
  cpanm ./Amon2-Setup-Flavor-Teng.tar.gz
  rm Amon2-Setup-Flavor-Teng.tar.gz
  cd $cwd
}

cpan-uninstall () {
  local MODULE
  for MODULE in $@
  do
    ${_SUDO} perl -MConfig -MExtUtils::Install -e '($FULLEXT=shift)=~s{::}{/}g;uninstall "$Config{sitearchexp}/auto/$FULLEXT/.packlist",1' $MODULE
  done
}

cpan-uninstall-perlbrew () {
  local MODULE
  for MODULE in $@
  do
    perl -MConfig -MExtUtils::Install -e '($FULLEXT=shift)=~s{::}{/}g;uninstall "$Config{sitearchexp}/auto/$FULLEXT/.packlist",1' $MODULE
  done
}

cpan-uninstall-locallib () {
  local MODULE
  for MODULE in $@
  do
    if [ "x${PERL_LOCAL_LIB_ROOT}" != "x"  -a -d  ${PERL_LOCAL_LIB_ROOT} ] ; then
      perl -MConfig -MExtUtils::Install -e '($FULLEXT=shift)=~s{::}{/}g; uninstall "$ENV{PERL_LOCAL_LIB_ROOT}/lib/perl5/$Config{archname}/auto/$FULLEXT/.packlist",1' $MODULE
    else
      echo 'environtal variable "PERL_LOCAL_LIB_ROOT" is not correct'
    fi
  done
}

yaml2pl () {
  local FILE
  local BASENAME
  for FILE in $@
  do 
    BASENAME=$(basename $FILE .yaml)
    BASENAME=$(basename $BASENAME .yml)
    perl -MYAML::Any -e 'use Data::Dumper; { package Data::Dumper; sub qquote{shift}; }
      use Encode; $Data::Dumper::Useperl=1; $Data::Dumper::Terse=1; print "+" . encode(q{utf8}, Dumper YAML::Any::LoadFile("$ARGV[0]"))' $FILE > $BASENAME.pl
  done
}

xml2yaml () {
  local FILE
  local BASENAME
  for FILE in $@
  do 
    BASENAME=$(basename $FILE .xml)
    perl -MYAML::Any -MXML::Simple -e 'print Dump XMLin "$ARGV[0]"' $FILE > $BASENAME.yaml
  done
}

json2yaml () {
  local FILE
  local BASENAME
  for FILE in $@
  do 
    BASENAME=$(basename $FILE .json)
    perl -MYAML::Any -MJSON -e 'open my $fh, "<", $ARGV[0] or die $!; print Dump JSON::decode_json(join(q{}, <$fh>));close $fh;' $FILE > $BASENAME.yml
  done
}

locallib () {
  echo "OLD PATH: $PATH"
  if [ "$1" = "" ] ; then
    echo 'usage: locallib [locallib path]'
  elif [ -d $1 ] ; then
    if [ "x$PERL_LOCAL_LIB_ROOT" != "x" ] ; then
      PATH=$(echo $PATH | sed "s#\(^\|:\)$PERL_LOCAL_LIB_ROOT\/bin:##")
    fi
    eval $(perl -Mlocal::lib=$1)
  else
    echo "$1 doen't exit"
  fi
  echo "NEW PATH: $PATH"
}

locallib_delete () {
  unset PERL_LOCAL_LIB_ROOT PERL_MB_OPT PERL_MM_OPT PERL5LIB
}

###
# ruby
###
install-rvm () {
  bash < <(curl -s https://raw.github.com/wayneeseguin/rvm/master/binscripts/rvm-installer )
}

install-rbenv () {
  git clone git://github.com/sstephenson/rbenv.git $HOME/.rbenv
  echo 'path=($HOME/.rbenv/bin(N-/) $path)' >> .zshenv
  echo 'eval "$(rbenv init -)"' >> .zshenv
  cd $HOME/.rbenv
  mkdir plugins
  cd plugins
  git clone git://github.com/sstephenson/ruby-build.git
  exec
  rbenv rehash
}

###
# python
###
install-pythonbrew () {
  curl -kL http://github.com/utahta/pythonbrew/raw/master/pythonbrew-install | bash
}

###
# rpm
###
rpm_list () {
  rpm2cpio $1 | cpio --list
}
rpm_extract () {
  rpm2cpio $1 | cpio -id
}

###
# mac
###
if is_mac ; then
  install-homebrew () {
    /usr/bin/ruby -e "$(curl -LfsS https://raw.github.com/mxcl/homebrew/master/Library/Contributions/install_homebrew.rb)"
  }
  brew-make-alias-of-coreutils () {
    brew ls coreutils 2>&1| grep /bin/g | perl -lne 'chomp; m{/bin/g(\w+)$} and print sprintf q{alias %s=g%s}, $1, $1 ' >> ~/.zsh/zshenv_coreutils_alias
  }
  install-vim () {
    brew install https://raw.github.com/AndrewVos/homebrew-alt/master/duplicates/vim.rb
    mv /usr/bin/vim /usr/bin/vim72
  }
  install-q4m-dev () {
    zsh -c "$(curl -fsSL https://raw.github.com/gist/1426403)"
  }
fi


###
# screen
###
if is_screen || is_tmux ; then
    preexec() {
        # see [zsh-workers:13180]
        # http://www.zsh.org/mla/workers/2000/msg03993.html
        emulate -L zsh
        local -a cmd; cmd=(${(z)2})
        case $cmd[1] in
            fg)
                if (( $#cmd == 1 )); then
                    cmd=(builtin jobs -l %+)
                else
                    cmd=(builtin jobs -l $cmd[2])
                fi
                ;;
            %*)
                cmd=(builtin jobs -l $cmd[1])
                ;;
            ls)
                return
                ;; 
            cd)
                if (( $#cmd == 2)); then
                    cmd[1]=$cmd[2]:t
                else
                    cmd[1]="~"
                fi
                change_status_title $cmd[1]
                prev=$cmd[1]
                return
                ;;
            vim|vi|gvim|sh|perl|bash)
                if (( $#cmd == 2)); then
                  cmd[1]="$cmd[1]:$cmd[2]:t"
                fi
                change_status_title $cmd[1]
                prev=$cmd[1]
                return
                ;;
            *)
                change_status_title $cmd[1]:t
                prev=$cmd[1]
                return
                ;;
        esac
        local -A jt; jt=(${(kv)jobtexts})
        $cmd >>(read num rest
            cmd=(${(z)${(e):-\$jt$num}})
            change_status_title $cmd[1]:t) 2>/dev/null
        prev=$cmd[1]
    }
#    precmd() {
#        change_status_title $:$prev:t
#    }
    change_status_title() {
      echo -n "k$1\\"
    }
fi 


if is_screen ; then
  function ssh_screen(){
    eval server=\${$#}
    recovery_ssh_auth_sock_if_lost_sock
    screen -t $server env SSH_AUTH_SOCK="$SSH_AUTH_SOCK" ssh "$@"
  }
  alias ssh=ssh_screen
  compdef _ssh ssh_screen=ssh
elif is_tmux ; then
  function ssh_tmux() {
    eval server=\${$#}
    recovery_ssh_auth_sock_if_lost_sock
    tmux neww -n $server "exec ssh $@"
  }
  function man_tmux() {
    tmux split-window "exec man $@"
  }
  alias ssh=ssh_tmux
  compdef _ssh ssh_tmux=ssh
  compdef _man man_tmux=man
fi

# cdd
source $HOME/.zsh/cdd
function chpwd() {
  if is_tmux ; then
    _reg_pwd_screennum
    tmux setenv TMUXPWD_$(tmux display -p "#I") $PWD
  elif is_screen ; then
    _reg_pwd_screennum
  fi
}
# //cdd



function ssh_resolve_cname () {
    TARGET=`host $1 | perl -e '$a=join q{},<>;$a=~m/is an alias for ([^\s]+)/; print $1'`
  if [ x$TARGET = x ] ; then
    ssh $@
  else
    shift
    echo $TARGET
    ssh $@ $TARGET
  fi
}

r() {
  local f
  f=(~/.zsh/functions/*(.))
  unfunction $f:t 2> /dev/null
  autoload -U $f:t
  compinit -u
}


###
# Prompt
###
setopt prompt_subst # enable to set escape sequence
#PROMPT='${WINDOW:+"[$WINDOW]"}%{$fg[cyan]%}%#%{$reset_color%} '
#RPROMPT='%{$fg[white]%}%~%{$fg[cyan]%}:%{$fg[white]%}%!%{$reset_color%}'
#if [[ -r /proc/loadavg ]]; then
#    PROMPT='%{$(load_avg)%}%m%{$reset_color%}'$PROMPT
#else
#    PROMPT='%m'$PROMPT
#fi

# バージョン管理システム
autoload -Uz vcs_info
zstyle ':vcs_info:*' formats '(%s)-[%b]'
zstyle ':vcs_info:*' actionformats '(%s)-[%b|%a]'

vcs_info 2>/dev/null 1>/dev/null
RET=$?
if [[ "$RET" == 0  ]] ; then
  call_vcs_info () {
    LANG=C vcs_info
    # バージョン管理下ならpsvar[1]に代入
    [[ -n "$vcs_info_msg_0_" ]] && psvar[1]="$vcs_info_msg_0_" 
  }
else
  call_vcs_info () {
  }
fi


precmd () {
  psvar=()
  call_vcs_info
  # local::libを利用していたらpsvar[2]に代入
  [[ -n "$PERL_LOCAL_LIB_ROOT" ]] && psvar[2]="$PERL_LOCAL_LIB_ROOT"
}


# %1(v|%F{green}%1v%f|)        : psvar[1]が存在すればgreenで表示
# %2(v|%F{magenta}%2v%f|)'     : psvar[2]が存在すればmagentaで表示
# %2(v|%F{magenta}(%2v%)%f |)' : 表示を'(psvar[2]) 'にしたバージョン
# %F{}%f                       : %fまでを%F{フォーマット指定}したフォーマットで表示
PROMPT='%{[$[32+$RANDOM % 5]m%}%U%B[%n@%m]%b%%%{[m%}%u '
#PROMPT='%{[$[32]m%}%U%B[%n@%m]'"%b%%%{[m%}%u "
#RPROMPT='%{[33m%}[%~]%{[m%}'
RPROMPT='%{[33m%}[%~]%{[m%}%1(v|%F{green}%1v%f|)%2(v|%F{magenta}(locallib:%2v%)%f|)'
#PROMPT='[%n@%m]%~%# '    # default prompt

###
# Environment variable
###
if is_mac  ; then
# avoid "/usr/bin/vim" exit code bug.
# if setting EDITOR=vim, /usr/bin/vim sometimes return 1 and fail to edit cron, commit log and so on
  export EDITOR=/usr/bin/vim
else
  eval `dircolors -b` # set LS_COLORS
  export EDITOR=vim
fi
export PAGER=less
export TZ=JST-9
export SHELL=/bin/zsh
export CVS_RSH=ssh
export SVN_SSH=ssh
export WORDCHARS='i*?_-.[]~=&;!#$%^(){}<>'
umask 022

bindkey -e             # emacs key bindings
#bindkey -v             # vi key bindings
bindkey ' ' magic-space  # also do history expansion on space
bindkey "^?" backward-delete-char # delete for debian


###
# keybord-history
###
HISTFILE=$HOME/.zsh-history           # 履歴をファイルに保存する
HISTSIZE=100000                       # メモリ内の履歴の数
SAVEHIST=100000                       # 保存される履歴の数
setopt extended_history               # 履歴ファイルに時刻を記録
setopt share_history
setopt hist_ignore_dups hist_ignore_space
function history-all { history -E 1 } # 全履歴の一覧を出力する
autoload history-search-end
zle -N history-beginning-search-backward-end history-search-end
zle -N history-beginning-search-forward-end history-search-end
bindkey "^P" history-beginning-search-backward-end
bindkey "^N" history-beginning-search-forward-end

###
# predict
###
#autoload predict-on
#predict-on

###
# command auto complete
###
zstyle ':completion:*:default' menu select=1
zstyle ':completion:*' verbose yes
zstyle ':completion:*:descriptions' format '%B%d%b'
zstyle ':completion:*:messages' format '%d'
zstyle ':completion:*:warnings' format 'No matches for: %d'
zstyle ':completion:*' group-name ''
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}  # color 
zstyle ':completion:*' use-cache true

# This file gives some examples of compctl commands.
# You can either put the compctl commands in your .zshrc
# or include a separate file from your .zshrc with the
# source command.

###
# complete database
###
# All completions for zsh.

# git-svn
_git-svn () {
    `git-svn --help | grep "^  \w" | sed "s/^  //" | sed "s/ .*//" | sed 's/^/ compadd /'`
}
compdef _git-svn git-svn

###
# hostname completion 
###

make_p () {
    local t s
    t="$1"; shift

    [ -f $t ] || return 0

    for s; do
  [ $s -nt $t ] && return 0
    done

    return 1
}

cache_hosts_file="$HOME/.cache_hosts"
known_hosts_file="$HOME/.ssh/known_hosts"

print_cache_hosts () {
    if [ -f $known_hosts_file ]; then
  awk '{ if (split($1, a, ",") > 1) for (i in a) { if (a[i] ~ /^[a-z]/) print a[i] } else print $1 }' $known_hosts_file
    fi
}

update_cache_hosts () {
    print_cache_hosts | sort -u > $cache_hosts_file
  if [ -f $known_hosts_file ]; then
    hostnames=(`perl -ne  'if (/^([a-zA-Z0-9.-]+)/) { print "$1\n";}' $known_hosts_file`) 
  elif [ -f /etc/hosts ]; then
    hostnames=(`awk '{print $2}' /etc/hosts`)
  else
    hostnames=(localhost)
  fi
}

make_p $cache_hosts_file $known_hosts_file && update_cache_hosts

_cache_hosts=( $(< $cache_hosts_file) )

# Some builtins.
compctl -j -P % fg bg wait jobs disown
compctl -A shift
compctl -caF whence which
compctl -F unfunction
compctl -a unalias
compctl -v unset typeset declare vared readonly export integer
compctl -e disable
compctl -d enable
compctl -k '(cputime filesize datasize stacksize coredumpsize resident \
  memoryuse memorylocked descriptors openfiles vmemorysize)' limit u{n,}limit
compctl -l '' -x 'p[1]' -f -- . source

###
# for directory operators
###
# Rmdir only real directories
compctl -g '(|.)*(-/)' rmdir dircmp rd mdcd mkdir
compctl -x 'p[2]' -k "(wheel staff ftpadmin okoma)"  -- pubmd

# vim:set ts=2 sw=2 et si:
